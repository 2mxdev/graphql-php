<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Class Reference - graphql-php</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Class Reference";
    var mkdocs_page_input_path = "reference.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> graphql-php</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">About</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../getting-started/">Getting Started</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../complementary-tools/">Complementary Tools</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Type Definitions</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../type-system/">Introduction</a>
                </li>
                <li class="">
                    
    <a class="" href="../type-system/object-types/">Object Types</a>
                </li>
                <li class="">
                    
    <a class="" href="../type-system/scalar-types/">Scalar Types</a>
                </li>
                <li class="">
                    
    <a class="" href="../type-system/enum-types/">Enumeration Types</a>
                </li>
                <li class="">
                    
    <a class="" href="../type-system/lists-and-nonnulls/">Lists and Non-Null</a>
                </li>
                <li class="">
                    
    <a class="" href="../type-system/interfaces/">Interfaces</a>
                </li>
                <li class="">
                    
    <a class="" href="../type-system/unions/">Unions</a>
                </li>
                <li class="">
                    
    <a class="" href="../type-system/input-types/">Mutations and Input Types</a>
                </li>
                <li class="">
                    
    <a class="" href="../type-system/directives/">Directives</a>
                </li>
                <li class="">
                    
    <a class="" href="../type-system/schema/">Schema</a>
                </li>
                <li class="">
                    
    <a class="" href="../type-system/type-language/">Using Type Language</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../executing-queries/">Executing Queries</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../data-fetching/">Fetching Data</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../error-handling/">Handling Errors</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../security/">Security</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../how-it-works/">How it works</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">Class Reference</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#graphqlgraphql">GraphQL\GraphQL</a></li>
    

    <li class="toctree-l2"><a href="#graphqltypedefinitiontype">GraphQL\Type\Definition\Type</a></li>
    

    <li class="toctree-l2"><a href="#graphqltypedefinitionresolveinfo">GraphQL\Type\Definition\ResolveInfo</a></li>
    

    <li class="toctree-l2"><a href="#graphqllanguagedirectivelocation">GraphQL\Language\DirectiveLocation</a></li>
    

    <li class="toctree-l2"><a href="#graphqltypeschemaconfig">GraphQL\Type\SchemaConfig</a></li>
    

    <li class="toctree-l2"><a href="#graphqltypeschema">GraphQL\Type\Schema</a></li>
    

    <li class="toctree-l2"><a href="#graphqllanguageparser">GraphQL\Language\Parser</a></li>
    

    <li class="toctree-l2"><a href="#graphqllanguageprinter">GraphQL\Language\Printer</a></li>
    

    <li class="toctree-l2"><a href="#graphqllanguagevisitor">GraphQL\Language\Visitor</a></li>
    

    <li class="toctree-l2"><a href="#graphqllanguageastnodekind">GraphQL\Language\AST\NodeKind</a></li>
    

    <li class="toctree-l2"><a href="#graphqlexecutorexecutor">GraphQL\Executor\Executor</a></li>
    

    <li class="toctree-l2"><a href="#graphqlexecutorexecutionresult">GraphQL\Executor\ExecutionResult</a></li>
    

    <li class="toctree-l2"><a href="#graphqlexecutorpromisepromiseadapter">GraphQL\Executor\Promise\PromiseAdapter</a></li>
    

    <li class="toctree-l2"><a href="#graphqlvalidatordocumentvalidator">GraphQL\Validator\DocumentValidator</a></li>
    

    <li class="toctree-l2"><a href="#graphqlerrorerror">GraphQL\Error\Error</a></li>
    

    <li class="toctree-l2"><a href="#graphqlerrorwarning">GraphQL\Error\Warning</a></li>
    

    <li class="toctree-l2"><a href="#graphqlerrorclientaware">GraphQL\Error\ClientAware</a></li>
    

    <li class="toctree-l2"><a href="#graphqlerrordebug">GraphQL\Error\Debug</a></li>
    

    <li class="toctree-l2"><a href="#graphqlerrorformattederror">GraphQL\Error\FormattedError</a></li>
    

    <li class="toctree-l2"><a href="#graphqlserverstandardserver">GraphQL\Server\StandardServer</a></li>
    

    <li class="toctree-l2"><a href="#graphqlserverserverconfig">GraphQL\Server\ServerConfig</a></li>
    

    <li class="toctree-l2"><a href="#graphqlserverhelper">GraphQL\Server\Helper</a></li>
    

    <li class="toctree-l2"><a href="#graphqlserveroperationparams">GraphQL\Server\OperationParams</a></li>
    

    <li class="toctree-l2"><a href="#graphqlutilsbuildschema">GraphQL\Utils\BuildSchema</a></li>
    

    <li class="toctree-l2"><a href="#graphqlutilsast">GraphQL\Utils\AST</a></li>
    

    <li class="toctree-l2"><a href="#graphqlutilsschemaprinter">GraphQL\Utils\SchemaPrinter</a></li>
    

    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">graphql-php</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Class Reference</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="graphqlgraphql">GraphQL\GraphQL</h1>
<p>This is the primary facade for fulfilling GraphQL operations.
See <a href="../executing-queries/">related documentation</a>.</p>
<p><strong>Class Methods:</strong> </p>
<pre><code class="php">/**
 * Executes graphql query.
 *
 * More sophisticated GraphQL servers, such as those which persist queries,
 * may wish to separate the validation and execution phases to a static time
 * tooling step, and a server runtime step.
 *
 * Available options:
 *
 * schema:
 *    The GraphQL type system to use when validating and executing a query.
 * source:
 *    A GraphQL language formatted string representing the requested operation.
 * rootValue:
 *    The value provided as the first argument to resolver functions on the top
 *    level type (e.g. the query object type).
 * context:
 *    The value provided as the third argument to all resolvers.
 *    Use this to pass current session, user data, etc
 * variableValues:
 *    A mapping of variable name to runtime value to use for all variables
 *    defined in the requestString.
 * operationName:
 *    The name of the operation to use if requestString contains multiple
 *    possible operations. Can be omitted if requestString contains only
 *    one operation.
 * fieldResolver:
 *    A resolver function to use when one is not provided by the schema.
 *    If not provided, the default field resolver is used (which looks for a
 *    value on the source value with the field's name).
 * validationRules:
 *    A set of rules for query validation step. Default value is all available rules.
 *    Empty array would allow to skip query validation (may be convenient for persisted
 *    queries which are validated before persisting and assumed valid during execution)
 *
 * @param string|DocumentNode $source
 * @param mixed               $rootValue
 * @param mixed               $context
 * @param mixed[]|null        $variableValues
 * @param ValidationRule[]    $validationRules
 *
 * @api
 */
static function executeQuery(
    GraphQL\Type\Schema $schema,
    $source,
    $rootValue = null,
    $context = null,
    $variableValues = null,
    string $operationName = null,
    callable $fieldResolver = null,
    array $validationRules = null
)
</code></pre>

<pre><code class="php">/**
 * Same as executeQuery(), but requires PromiseAdapter and always returns a Promise.
 * Useful for Async PHP platforms.
 *
 * @param string|DocumentNode   $source
 * @param mixed                 $rootValue
 * @param mixed                 $context
 * @param mixed[]|null          $variableValues
 * @param ValidationRule[]|null $validationRules
 *
 * @api
 */
static function promiseToExecute(
    GraphQL\Executor\Promise\PromiseAdapter $promiseAdapter,
    GraphQL\Type\Schema $schema,
    $source,
    $rootValue = null,
    $context = null,
    $variableValues = null,
    string $operationName = null,
    callable $fieldResolver = null,
    array $validationRules = null
)
</code></pre>

<pre><code class="php">/**
 * Returns directives defined in GraphQL spec
 *
 * @return Directive[]
 *
 * @api
 */
static function getStandardDirectives()
</code></pre>

<pre><code class="php">/**
 * Returns types defined in GraphQL spec
 *
 * @return Type[]
 *
 * @api
 */
static function getStandardTypes()
</code></pre>

<pre><code class="php">/**
 * Replaces standard types with types from this list (matching by name)
 * Standard types not listed here remain untouched.
 *
 * @param Type[] $types
 *
 * @api
 */
static function overrideStandardTypes(array $types)
</code></pre>

<pre><code class="php">/**
 * Returns standard validation rules implementing GraphQL spec
 *
 * @return ValidationRule[]
 *
 * @api
 */
static function getStandardValidationRules()
</code></pre>

<pre><code class="php">/**
 * Set default resolver implementation
 *
 * @api
 */
static function setDefaultFieldResolver(callable $fn)
</code></pre>

<h1 id="graphqltypedefinitiontype">GraphQL\Type\Definition\Type</h1>
<p>Registry of standard GraphQL types
and a base class for all other types.</p>
<p><strong>Class Methods:</strong> </p>
<pre><code class="php">/**
 * @return IDType
 *
 * @api
 */
static function id()
</code></pre>

<pre><code class="php">/**
 * @return StringType
 *
 * @api
 */
static function string()
</code></pre>

<pre><code class="php">/**
 * @return BooleanType
 *
 * @api
 */
static function boolean()
</code></pre>

<pre><code class="php">/**
 * @return IntType
 *
 * @api
 */
static function int()
</code></pre>

<pre><code class="php">/**
 * @return FloatType
 *
 * @api
 */
static function float()
</code></pre>

<pre><code class="php">/**
 * @param Type|ObjectType|InterfaceType|UnionType|ScalarType|InputObjectType|EnumType|ListOfType|NonNull $wrappedType
 *
 * @return ListOfType
 *
 * @api
 */
static function listOf($wrappedType)
</code></pre>

<pre><code class="php">/**
 * @param ObjectType|InterfaceType|UnionType|ScalarType|InputObjectType|EnumType|ListOfType $wrappedType
 *
 * @return NonNull
 *
 * @api
 */
static function nonNull($wrappedType)
</code></pre>

<pre><code class="php">/**
 * @param Type $type
 *
 * @return bool
 *
 * @api
 */
static function isInputType($type)
</code></pre>

<pre><code class="php">/**
 * @param Type $type
 *
 * @return ObjectType|InterfaceType|UnionType|ScalarType|InputObjectType|EnumType
 *
 * @api
 */
static function getNamedType($type)
</code></pre>

<pre><code class="php">/**
 * @param Type $type
 *
 * @return bool
 *
 * @api
 */
static function isOutputType($type)
</code></pre>

<pre><code class="php">/**
 * @param Type $type
 *
 * @return bool
 *
 * @api
 */
static function isLeafType($type)
</code></pre>

<pre><code class="php">/**
 * @param Type $type
 *
 * @return bool
 *
 * @api
 */
static function isCompositeType($type)
</code></pre>

<pre><code class="php">/**
 * @param Type $type
 *
 * @return bool
 *
 * @api
 */
static function isAbstractType($type)
</code></pre>

<pre><code class="php">/**
 * @param Type $type
 *
 * @return bool
 *
 * @api
 */
static function isType($type)
</code></pre>

<pre><code class="php">/**
 * @param Type $type
 *
 * @return ObjectType|InterfaceType|UnionType|ScalarType|InputObjectType|EnumType|ListOfType
 *
 * @api
 */
static function getNullableType($type)
</code></pre>

<h1 id="graphqltypedefinitionresolveinfo">GraphQL\Type\Definition\ResolveInfo</h1>
<p>Structure containing information useful for field resolution process.
Passed as 3rd argument to every field resolver. See <a href="../data-fetching/">docs on field resolving (data fetching)</a>.</p>
<p><strong>Class Props:</strong> </p>
<pre><code class="php">/**
 * The name of the field being resolved
 *
 * @api
 * @var string|null
 */
public $fieldName;

/**
 * AST of all nodes referencing this field in the query.
 *
 * @api
 * @var FieldNode[]|null
 */
public $fieldNodes;

/**
 * Expected return type of the field being resolved
 *
 * @api
 * @var ScalarType|ObjectType|InterfaceType|UnionType|EnumType|ListOfType|NonNull
 */
public $returnType;

/**
 * Parent type of the field being resolved
 *
 * @api
 * @var ObjectType|null
 */
public $parentType;

/**
 * Path to this field from the very root value
 *
 * @api
 * @var string[]
 */
public $path;

/**
 * Instance of a schema used for execution
 *
 * @api
 * @var Schema|null
 */
public $schema;

/**
 * AST of all fragments defined in query
 *
 * @api
 * @var FragmentDefinitionNode[]|null
 */
public $fragments;

/**
 * Root value passed to query execution
 *
 * @api
 * @var mixed|null
 */
public $rootValue;

/**
 * AST of operation definition node (query, mutation)
 *
 * @api
 * @var OperationDefinitionNode|null
 */
public $operation;

/**
 * Array of variables passed to query execution
 *
 * @api
 * @var mixed[]|null
 */
public $variableValues;
</code></pre>

<p><strong>Class Methods:</strong> </p>
<pre><code class="php">/**
 * Helper method that returns names of all fields selected in query for
 * $this-&gt;fieldName up to $depth levels
 *
 * Example:
 * query MyQuery{
 * {
 *   root {
 *     id,
 *     nested {
 *      nested1
 *      nested2 {
 *        nested3
 *      }
 *     }
 *   }
 * }
 *
 * Given this ResolveInfo instance is a part of &quot;root&quot; field resolution, and $depth === 1,
 * method will return:
 * [
 *     'id' =&gt; true,
 *     'nested' =&gt; [
 *         nested1 =&gt; true,
 *         nested2 =&gt; true
 *     ]
 * ]
 *
 * Warning: this method it is a naive implementation which does not take into account
 * conditional typed fragments. So use it with care for fields of interface and union types.
 *
 * @param int $depth How many levels to include in output
 *
 * @return bool[]
 *
 * @api
 */
function getFieldSelection($depth = 0)
</code></pre>

<h1 id="graphqllanguagedirectivelocation">GraphQL\Language\DirectiveLocation</h1>
<p>List of available directive locations</p>
<p><strong>Class Constants:</strong> </p>
<pre><code class="php">const QUERY = &quot;QUERY&quot;;
const MUTATION = &quot;MUTATION&quot;;
const SUBSCRIPTION = &quot;SUBSCRIPTION&quot;;
const FIELD = &quot;FIELD&quot;;
const FRAGMENT_DEFINITION = &quot;FRAGMENT_DEFINITION&quot;;
const FRAGMENT_SPREAD = &quot;FRAGMENT_SPREAD&quot;;
const INLINE_FRAGMENT = &quot;INLINE_FRAGMENT&quot;;
const SCHEMA = &quot;SCHEMA&quot;;
const SCALAR = &quot;SCALAR&quot;;
const OBJECT = &quot;OBJECT&quot;;
const FIELD_DEFINITION = &quot;FIELD_DEFINITION&quot;;
const ARGUMENT_DEFINITION = &quot;ARGUMENT_DEFINITION&quot;;
const IFACE = &quot;INTERFACE&quot;;
const UNION = &quot;UNION&quot;;
const ENUM = &quot;ENUM&quot;;
const ENUM_VALUE = &quot;ENUM_VALUE&quot;;
const INPUT_OBJECT = &quot;INPUT_OBJECT&quot;;
const INPUT_FIELD_DEFINITION = &quot;INPUT_FIELD_DEFINITION&quot;;
</code></pre>

<h1 id="graphqltypeschemaconfig">GraphQL\Type\SchemaConfig</h1>
<p>Schema configuration class.
Could be passed directly to schema constructor. List of options accepted by <strong>create</strong> method is
<a href="../type-system/schema/#configuration-options">described in docs</a>.</p>
<p>Usage example:</p>
<pre><code>$config = SchemaConfig::create()
    -&gt;setQuery($myQueryType)
    -&gt;setTypeLoader($myTypeLoader);

$schema = new Schema($config);
</code></pre>
<p><strong>Class Methods:</strong> </p>
<pre><code class="php">/**
 * Converts an array of options to instance of SchemaConfig
 * (or just returns empty config when array is not passed).
 *
 * @param mixed[] $options
 *
 * @return SchemaConfig
 *
 * @api
 */
static function create(array $options = [])
</code></pre>

<pre><code class="php">/**
 * @return ObjectType
 *
 * @api
 */
function getQuery()
</code></pre>

<pre><code class="php">/**
 * @param ObjectType $query
 *
 * @return SchemaConfig
 *
 * @api
 */
function setQuery($query)
</code></pre>

<pre><code class="php">/**
 * @return ObjectType
 *
 * @api
 */
function getMutation()
</code></pre>

<pre><code class="php">/**
 * @param ObjectType $mutation
 *
 * @return SchemaConfig
 *
 * @api
 */
function setMutation($mutation)
</code></pre>

<pre><code class="php">/**
 * @return ObjectType
 *
 * @api
 */
function getSubscription()
</code></pre>

<pre><code class="php">/**
 * @param ObjectType $subscription
 *
 * @return SchemaConfig
 *
 * @api
 */
function setSubscription($subscription)
</code></pre>

<pre><code class="php">/**
 * @return Type[]
 *
 * @api
 */
function getTypes()
</code></pre>

<pre><code class="php">/**
 * @param Type[]|callable $types
 *
 * @return SchemaConfig
 *
 * @api
 */
function setTypes($types)
</code></pre>

<pre><code class="php">/**
 * @return Directive[]
 *
 * @api
 */
function getDirectives()
</code></pre>

<pre><code class="php">/**
 * @param Directive[] $directives
 *
 * @return SchemaConfig
 *
 * @api
 */
function setDirectives(array $directives)
</code></pre>

<pre><code class="php">/**
 * @return callable
 *
 * @api
 */
function getTypeLoader()
</code></pre>

<pre><code class="php">/**
 * @return SchemaConfig
 *
 * @api
 */
function setTypeLoader(callable $typeLoader)
</code></pre>

<h1 id="graphqltypeschema">GraphQL\Type\Schema</h1>
<p>Schema Definition (see <a href="../type-system/schema/">related docs</a>)</p>
<p>A Schema is created by supplying the root types of each type of operation:
query, mutation (optional) and subscription (optional). A schema definition is
then supplied to the validator and executor. Usage Example:</p>
<pre><code>$schema = new GraphQL\Type\Schema([
  'query' =&gt; $MyAppQueryRootType,
  'mutation' =&gt; $MyAppMutationRootType,
]);
</code></pre>
<p>Or using Schema Config instance:</p>
<pre><code>$config = GraphQL\Type\SchemaConfig::create()
    -&gt;setQuery($MyAppQueryRootType)
    -&gt;setMutation($MyAppMutationRootType);

$schema = new GraphQL\Type\Schema($config);
</code></pre>
<p><strong>Class Methods:</strong> </p>
<pre><code class="php">/**
 * @param mixed[]|SchemaConfig $config
 *
 * @api
 */
function __construct($config)
</code></pre>

<pre><code class="php">/**
 * Returns array of all types in this schema. Keys of this array represent type names, values are instances
 * of corresponding type definitions
 *
 * This operation requires full schema scan. Do not use in production environment.
 *
 * @return Type[]
 *
 * @api
 */
function getTypeMap()
</code></pre>

<pre><code class="php">/**
 * Returns a list of directives supported by this schema
 *
 * @return Directive[]
 *
 * @api
 */
function getDirectives()
</code></pre>

<pre><code class="php">/**
 * Returns schema query type
 *
 * @return ObjectType
 *
 * @api
 */
function getQueryType()
</code></pre>

<pre><code class="php">/**
 * Returns schema mutation type
 *
 * @return ObjectType|null
 *
 * @api
 */
function getMutationType()
</code></pre>

<pre><code class="php">/**
 * Returns schema subscription
 *
 * @return ObjectType|null
 *
 * @api
 */
function getSubscriptionType()
</code></pre>

<pre><code class="php">/**
 * @return SchemaConfig
 *
 * @api
 */
function getConfig()
</code></pre>

<pre><code class="php">/**
 * Returns type by it's name
 *
 * @param string $name
 *
 * @return Type|null
 *
 * @api
 */
function getType($name)
</code></pre>

<pre><code class="php">/**
 * Returns all possible concrete types for given abstract type
 * (implementations for interfaces and members of union type for unions)
 *
 * This operation requires full schema scan. Do not use in production environment.
 *
 * @return ObjectType[]
 *
 * @api
 */
function getPossibleTypes(GraphQL\Type\Definition\AbstractType $abstractType)
</code></pre>

<pre><code class="php">/**
 * Returns true if object type is concrete type of given abstract type
 * (implementation for interfaces and members of union type for unions)
 *
 * @return bool
 *
 * @api
 */
function isPossibleType(
    GraphQL\Type\Definition\AbstractType $abstractType,
    GraphQL\Type\Definition\ObjectType $possibleType
)
</code></pre>

<pre><code class="php">/**
 * Returns instance of directive by name
 *
 * @param string $name
 *
 * @return Directive
 *
 * @api
 */
function getDirective($name)
</code></pre>

<pre><code class="php">/**
 * Validates schema.
 *
 * This operation requires full schema scan. Do not use in production environment.
 *
 * @throws InvariantViolation
 *
 * @api
 */
function assertValid()
</code></pre>

<pre><code class="php">/**
 * Validates schema.
 *
 * This operation requires full schema scan. Do not use in production environment.
 *
 * @return InvariantViolation[]|Error[]
 *
 * @api
 */
function validate()
</code></pre>

<h1 id="graphqllanguageparser">GraphQL\Language\Parser</h1>
<p>Parses string containing GraphQL query or <a href="../type-system/type-language/">type definition</a> to Abstract Syntax Tree.</p>
<p><strong>Class Methods:</strong> </p>
<pre><code class="php">/**
 * Given a GraphQL source, parses it into a `GraphQL\Language\AST\DocumentNode`.
 * Throws `GraphQL\Error\SyntaxError` if a syntax error is encountered.
 *
 * Available options:
 *
 * noLocation: boolean,
 *   (By default, the parser creates AST nodes that know the location
 *   in the source that they correspond to. This configuration flag
 *   disables that behavior for performance or testing.)
 *
 * allowLegacySDLEmptyFields: boolean
 *   If enabled, the parser will parse empty fields sets in the Schema
 *   Definition Language. Otherwise, the parser will follow the current
 *   specification.
 *
 *   This option is provided to ease adoption of the final SDL specification
 *   and will be removed in a future major release.
 *
 * allowLegacySDLImplementsInterfaces: boolean
 *   If enabled, the parser will parse implemented interfaces with no `&amp;`
 *   character between each interface. Otherwise, the parser will follow the
 *   current specification.
 *
 *   This option is provided to ease adoption of the final SDL specification
 *   and will be removed in a future major release.
 *
 * experimentalFragmentVariables: boolean,
 *   (If enabled, the parser will understand and parse variable definitions
 *   contained in a fragment definition. They'll be represented in the
 *   `variableDefinitions` field of the FragmentDefinitionNode.
 *
 *   The syntax is identical to normal, query-defined variables. For example:
 *
 *     fragment A($var: Boolean = false) on T  {
 *       ...
 *     }
 *
 *   Note: this feature is experimental and may change or be removed in the
 *   future.)
 *
 * @param Source|string $source
 * @param bool[]        $options
 *
 * @return DocumentNode
 *
 * @throws SyntaxError
 *
 * @api
 */
static function parse($source, array $options = [])
</code></pre>

<pre><code class="php">/**
 * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for
 * that value.
 * Throws `GraphQL\Error\SyntaxError` if a syntax error is encountered.
 *
 * This is useful within tools that operate upon GraphQL Values directly and
 * in isolation of complete GraphQL documents.
 *
 * Consider providing the results to the utility function: `GraphQL\Utils\AST::valueFromAST()`.
 *
 * @param Source|string $source
 * @param bool[]        $options
 *
 * @return BooleanValueNode|EnumValueNode|FloatValueNode|IntValueNode|ListValueNode|ObjectValueNode|StringValueNode|VariableNode
 *
 * @api
 */
static function parseValue($source, array $options = [])
</code></pre>

<pre><code class="php">/**
 * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for
 * that type.
 * Throws `GraphQL\Error\SyntaxError` if a syntax error is encountered.
 *
 * This is useful within tools that operate upon GraphQL Types directly and
 * in isolation of complete GraphQL documents.
 *
 * Consider providing the results to the utility function: `GraphQL\Utils\AST::typeFromAST()`.
 *
 * @param Source|string $source
 * @param bool[]        $options
 *
 * @return ListTypeNode|NameNode|NonNullTypeNode
 *
 * @api
 */
static function parseType($source, array $options = [])
</code></pre>

<h1 id="graphqllanguageprinter">GraphQL\Language\Printer</h1>
<p>Prints AST to string. Capable of printing GraphQL queries and Type definition language.
Useful for pretty-printing queries or printing back AST for logging, documentation, etc.</p>
<p>Usage example:</p>
<pre><code class="php">$query = 'query myQuery {someField}';
$ast = GraphQL\Language\Parser::parse($query);
$printed = GraphQL\Language\Printer::doPrint($ast);
</code></pre>

<p><strong>Class Methods:</strong> </p>
<pre><code class="php">/**
 * Prints AST to string. Capable of printing GraphQL queries and Type definition language.
 *
 * @param Node $ast
 *
 * @return string
 *
 * @api
 */
static function doPrint($ast)
</code></pre>

<h1 id="graphqllanguagevisitor">GraphQL\Language\Visitor</h1>
<p>Utility for efficient AST traversal and modification.</p>
<p><code>visit()</code> will walk through an AST using a depth first traversal, calling
the visitor's enter function at each node in the traversal, and calling the
leave function after visiting that node and all of it's child nodes.</p>
<p>By returning different values from the enter and leave functions, the
behavior of the visitor can be altered, including skipping over a sub-tree of
the AST (by returning false), editing the AST by returning a value or null
to remove the value, or to stop the whole traversal by returning BREAK.</p>
<p>When using <code>visit()</code> to edit an AST, the original AST will not be modified, and
a new version of the AST with the changes applied will be returned from the
visit function.</p>
<pre><code>$editedAST = Visitor::visit($ast, [
  'enter' =&gt; function ($node, $key, $parent, $path, $ancestors) {
    // return
    //   null: no action
    //   Visitor::skipNode(): skip visiting this node
    //   Visitor::stop(): stop visiting altogether
    //   Visitor::removeNode(): delete this node
    //   any value: replace this node with the returned value
  },
  'leave' =&gt; function ($node, $key, $parent, $path, $ancestors) {
    // return
    //   null: no action
    //   Visitor::stop(): stop visiting altogether
    //   Visitor::removeNode(): delete this node
    //   any value: replace this node with the returned value
  }
]);
</code></pre>
<p>Alternatively to providing enter() and leave() functions, a visitor can
instead provide functions named the same as the <a href="./#graphqllanguageastnodekind">kinds of AST nodes</a>,
or enter/leave visitors at a named key, leading to four permutations of
visitor API:</p>
<p>1) Named visitors triggered when entering a node a specific kind.</p>
<pre><code>Visitor::visit($ast, [
  'Kind' =&gt; function ($node) {
    // enter the "Kind" node
  }
]);
</code></pre>
<p>2) Named visitors that trigger upon entering and leaving a node of
   a specific kind.</p>
<pre><code>Visitor::visit($ast, [
  'Kind' =&gt; [
    'enter' =&gt; function ($node) {
      // enter the "Kind" node
    }
    'leave' =&gt; function ($node) {
      // leave the "Kind" node
    }
  ]
]);
</code></pre>
<p>3) Generic visitors that trigger upon entering and leaving any node.</p>
<pre><code>Visitor::visit($ast, [
  'enter' =&gt; function ($node) {
    // enter any node
  },
  'leave' =&gt; function ($node) {
    // leave any node
  }
]);
</code></pre>
<p>4) Parallel visitors for entering and leaving nodes of a specific kind.</p>
<pre><code>Visitor::visit($ast, [
  'enter' =&gt; [
    'Kind' =&gt; function($node) {
      // enter the "Kind" node
    }
  },
  'leave' =&gt; [
    'Kind' =&gt; function ($node) {
      // leave the "Kind" node
    }
  ]
]);
</code></pre>
<p><strong>Class Methods:</strong> </p>
<pre><code class="php">/**
 * Visit the AST (see class description for details)
 *
 * @param Node|ArrayObject|stdClass $root
 * @param callable[]                $visitor
 * @param mixed[]|null              $keyMap
 *
 * @return Node|mixed
 *
 * @throws Exception
 *
 * @api
 */
static function visit($root, $visitor, $keyMap = null)
</code></pre>

<pre><code class="php">/**
 * Returns marker for visitor break
 *
 * @return VisitorOperation
 *
 * @api
 */
static function stop()
</code></pre>

<pre><code class="php">/**
 * Returns marker for skipping current node
 *
 * @return VisitorOperation
 *
 * @api
 */
static function skipNode()
</code></pre>

<pre><code class="php">/**
 * Returns marker for removing a node
 *
 * @return VisitorOperation
 *
 * @api
 */
static function removeNode()
</code></pre>

<h1 id="graphqllanguageastnodekind">GraphQL\Language\AST\NodeKind</h1>
<p><strong>Class Constants:</strong> </p>
<pre><code class="php">const NAME = &quot;Name&quot;;
const DOCUMENT = &quot;Document&quot;;
const OPERATION_DEFINITION = &quot;OperationDefinition&quot;;
const VARIABLE_DEFINITION = &quot;VariableDefinition&quot;;
const VARIABLE = &quot;Variable&quot;;
const SELECTION_SET = &quot;SelectionSet&quot;;
const FIELD = &quot;Field&quot;;
const ARGUMENT = &quot;Argument&quot;;
const FRAGMENT_SPREAD = &quot;FragmentSpread&quot;;
const INLINE_FRAGMENT = &quot;InlineFragment&quot;;
const FRAGMENT_DEFINITION = &quot;FragmentDefinition&quot;;
const INT = &quot;IntValue&quot;;
const FLOAT = &quot;FloatValue&quot;;
const STRING = &quot;StringValue&quot;;
const BOOLEAN = &quot;BooleanValue&quot;;
const ENUM = &quot;EnumValue&quot;;
const NULL = &quot;NullValue&quot;;
const LST = &quot;ListValue&quot;;
const OBJECT = &quot;ObjectValue&quot;;
const OBJECT_FIELD = &quot;ObjectField&quot;;
const DIRECTIVE = &quot;Directive&quot;;
const NAMED_TYPE = &quot;NamedType&quot;;
const LIST_TYPE = &quot;ListType&quot;;
const NON_NULL_TYPE = &quot;NonNullType&quot;;
const SCHEMA_DEFINITION = &quot;SchemaDefinition&quot;;
const OPERATION_TYPE_DEFINITION = &quot;OperationTypeDefinition&quot;;
const SCALAR_TYPE_DEFINITION = &quot;ScalarTypeDefinition&quot;;
const OBJECT_TYPE_DEFINITION = &quot;ObjectTypeDefinition&quot;;
const FIELD_DEFINITION = &quot;FieldDefinition&quot;;
const INPUT_VALUE_DEFINITION = &quot;InputValueDefinition&quot;;
const INTERFACE_TYPE_DEFINITION = &quot;InterfaceTypeDefinition&quot;;
const UNION_TYPE_DEFINITION = &quot;UnionTypeDefinition&quot;;
const ENUM_TYPE_DEFINITION = &quot;EnumTypeDefinition&quot;;
const ENUM_VALUE_DEFINITION = &quot;EnumValueDefinition&quot;;
const INPUT_OBJECT_TYPE_DEFINITION = &quot;InputObjectTypeDefinition&quot;;
const SCALAR_TYPE_EXTENSION = &quot;ScalarTypeExtension&quot;;
const OBJECT_TYPE_EXTENSION = &quot;ObjectTypeExtension&quot;;
const INTERFACE_TYPE_EXTENSION = &quot;InterfaceTypeExtension&quot;;
const UNION_TYPE_EXTENSION = &quot;UnionTypeExtension&quot;;
const ENUM_TYPE_EXTENSION = &quot;EnumTypeExtension&quot;;
const INPUT_OBJECT_TYPE_EXTENSION = &quot;InputObjectTypeExtension&quot;;
const DIRECTIVE_DEFINITION = &quot;DirectiveDefinition&quot;;
const SCHEMA_EXTENSION = &quot;SchemaExtension&quot;;
</code></pre>

<h1 id="graphqlexecutorexecutor">GraphQL\Executor\Executor</h1>
<p>Implements the "Evaluating requests" section of the GraphQL specification.</p>
<p><strong>Class Methods:</strong> </p>
<pre><code class="php">/**
 * Executes DocumentNode against given $schema.
 *
 * Always returns ExecutionResult and never throws. All errors which occur during operation
 * execution are collected in `$result-&gt;errors`.
 *
 * @param mixed|null               $rootValue
 * @param mixed[]|null             $contextValue
 * @param mixed[]|ArrayAccess|null $variableValues
 * @param string|null              $operationName
 *
 * @return ExecutionResult|Promise
 *
 * @api
 */
static function execute(
    GraphQL\Type\Schema $schema,
    GraphQL\Language\AST\DocumentNode $documentNode,
    $rootValue = null,
    $contextValue = null,
    $variableValues = null,
    $operationName = null,
    callable $fieldResolver = null
)
</code></pre>

<pre><code class="php">/**
 * Same as execute(), but requires promise adapter and returns a promise which is always
 * fulfilled with an instance of ExecutionResult and never rejected.
 *
 * Useful for async PHP platforms.
 *
 * @param mixed[]|null $rootValue
 * @param mixed[]|null $contextValue
 * @param mixed[]|null $variableValues
 * @param string|null  $operationName
 *
 * @return Promise
 *
 * @api
 */
static function promiseToExecute(
    GraphQL\Executor\Promise\PromiseAdapter $promiseAdapter,
    GraphQL\Type\Schema $schema,
    GraphQL\Language\AST\DocumentNode $documentNode,
    $rootValue = null,
    $contextValue = null,
    $variableValues = null,
    $operationName = null,
    callable $fieldResolver = null
)
</code></pre>

<h1 id="graphqlexecutorexecutionresult">GraphQL\Executor\ExecutionResult</h1>
<p>Returned after <a href="../executing-queries/">query execution</a>.
Represents both - result of successful execution and of a failed one
(with errors collected in <code>errors</code> prop)</p>
<p>Could be converted to <a href="https://facebook.github.io/graphql/#sec-Response-Format">spec-compliant</a>
serializable array using <code>toArray()</code></p>
<p><strong>Class Props:</strong> </p>
<pre><code class="php">/**
 * Data collected from resolvers during query execution
 *
 * @api
 * @var mixed[]
 */
public $data;

/**
 * Errors registered during query execution.
 *
 * If an error was caused by exception thrown in resolver, $error-&gt;getPrevious() would
 * contain original exception.
 *
 * @api
 * @var Error[]
 */
public $errors;

/**
 * User-defined serializable array of extensions included in serialized result.
 * Conforms to
 *
 * @api
 * @var mixed[]
 */
public $extensions;
</code></pre>

<p><strong>Class Methods:</strong> </p>
<pre><code class="php">/**
 * Define custom error formatting (must conform to http://facebook.github.io/graphql/#sec-Errors)
 *
 * Expected signature is: function (GraphQL\Error\Error $error): array
 *
 * Default formatter is &quot;GraphQL\Error\FormattedError::createFromException&quot;
 *
 * Expected returned value must be an array:
 * array(
 *    'message' =&gt; 'errorMessage',
 *    // ... other keys
 * );
 *
 * @return self
 *
 * @api
 */
function setErrorFormatter(callable $errorFormatter)
</code></pre>

<pre><code class="php">/**
 * Define custom logic for error handling (filtering, logging, etc).
 *
 * Expected handler signature is: function (array $errors, callable $formatter): array
 *
 * Default handler is:
 * function (array $errors, callable $formatter) {
 *     return array_map($formatter, $errors);
 * }
 *
 * @return self
 *
 * @api
 */
function setErrorsHandler(callable $handler)
</code></pre>

<pre><code class="php">/**
 * Converts GraphQL query result to spec-compliant serializable array using provided
 * errors handler and formatter.
 *
 * If debug argument is passed, output of error formatter is enriched which debugging information
 * (&quot;debugMessage&quot;, &quot;trace&quot; keys depending on flags).
 *
 * $debug argument must be either bool (only adds &quot;debugMessage&quot; to result) or sum of flags from
 * GraphQL\Error\Debug
 *
 * @param bool|int $debug
 *
 * @return mixed[]
 *
 * @api
 */
function toArray($debug = false)
</code></pre>

<h1 id="graphqlexecutorpromisepromiseadapter">GraphQL\Executor\Promise\PromiseAdapter</h1>
<p>Provides a means for integration of async PHP platforms (<a href="../data-fetching/#async-php">related docs</a>)</p>
<p><strong>Interface Methods:</strong> </p>
<pre><code class="php">/**
 * Return true if the value is a promise or a deferred of the underlying platform
 *
 * @param mixed $value
 *
 * @return bool
 *
 * @api
 */
function isThenable($value)
</code></pre>

<pre><code class="php">/**
 * Converts thenable of the underlying platform into GraphQL\Executor\Promise\Promise instance
 *
 * @param object $thenable
 *
 * @return Promise
 *
 * @api
 */
function convertThenable($thenable)
</code></pre>

<pre><code class="php">/**
 * Accepts our Promise wrapper, extracts adopted promise out of it and executes actual `then` logic described
 * in Promises/A+ specs. Then returns new wrapped instance of GraphQL\Executor\Promise\Promise.
 *
 * @return Promise
 *
 * @api
 */
function then(
    GraphQL\Executor\Promise\Promise $promise,
    callable $onFulfilled = null,
    callable $onRejected = null
)
</code></pre>

<pre><code class="php">/**
 * Creates a Promise
 *
 * Expected resolver signature:
 *     function(callable $resolve, callable $reject)
 *
 * @return Promise
 *
 * @api
 */
function create(callable $resolver)
</code></pre>

<pre><code class="php">/**
 * Creates a fulfilled Promise for a value if the value is not a promise.
 *
 * @param mixed $value
 *
 * @return Promise
 *
 * @api
 */
function createFulfilled($value = null)
</code></pre>

<pre><code class="php">/**
 * Creates a rejected promise for a reason if the reason is not a promise. If
 * the provided reason is a promise, then it is returned as-is.
 *
 * @param Throwable $reason
 *
 * @return Promise
 *
 * @api
 */
function createRejected($reason)
</code></pre>

<pre><code class="php">/**
 * Given an array of promises (or values), returns a promise that is fulfilled when all the
 * items in the array are fulfilled.
 *
 * @param Promise[]|mixed[] $promisesOrValues Promises or values.
 *
 * @return Promise
 *
 * @api
 */
function all(array $promisesOrValues)
</code></pre>

<h1 id="graphqlvalidatordocumentvalidator">GraphQL\Validator\DocumentValidator</h1>
<p>Implements the "Validation" section of the spec.</p>
<p>Validation runs synchronously, returning an array of encountered errors, or
an empty array if no errors were encountered and the document is valid.</p>
<p>A list of specific validation rules may be provided. If not provided, the
default list of rules defined by the GraphQL specification will be used.</p>
<p>Each validation rule is an instance of GraphQL\Validator\Rules\ValidationRule
which returns a visitor (see the <a href="./#graphqllanguagevisitor">GraphQL\Language\Visitor API</a>).</p>
<p>Visitor methods are expected to return an instance of <a href="./#graphqlerrorerror">GraphQL\Error\Error</a>,
or array of such instances when invalid.</p>
<p>Optionally a custom TypeInfo instance may be provided. If not provided, one
will be created from the provided schema.</p>
<p><strong>Class Methods:</strong> </p>
<pre><code class="php">/**
 * Primary method for query validation. See class description for details.
 *
 * @param ValidationRule[]|null $rules
 *
 * @return Error[]
 *
 * @api
 */
static function validate(
    GraphQL\Type\Schema $schema,
    GraphQL\Language\AST\DocumentNode $ast,
    array $rules = null,
    GraphQL\Utils\TypeInfo $typeInfo = null
)
</code></pre>

<pre><code class="php">/**
 * Returns all global validation rules.
 *
 * @return ValidationRule[]
 *
 * @api
 */
static function allRules()
</code></pre>

<pre><code class="php">/**
 * Returns global validation rule by name. Standard rules are named by class name, so
 * example usage for such rules:
 *
 * $rule = DocumentValidator::getRule(GraphQL\Validator\Rules\QueryComplexity::class);
 *
 * @param string $name
 *
 * @return ValidationRule
 *
 * @api
 */
static function getRule($name)
</code></pre>

<pre><code class="php">/**
 * Add rule to list of global validation rules
 *
 * @api
 */
static function addRule(GraphQL\Validator\Rules\ValidationRule $rule)
</code></pre>

<h1 id="graphqlerrorerror">GraphQL\Error\Error</h1>
<p>Describes an Error found during the parse, validate, or
execute phases of performing a GraphQL operation. In addition to a message
and stack trace, it also includes information about the locations in a
GraphQL document and/or execution result that correspond to the Error.</p>
<p>When the error was caused by an exception thrown in resolver, original exception
is available via <code>getPrevious()</code>.</p>
<p>Also read related docs on <a href="../error-handling/">error handling</a></p>
<p>Class extends standard PHP <code>\Exception</code>, so all standard methods of base <code>\Exception</code> class
are available in addition to those listed below.</p>
<p><strong>Class Constants:</strong> </p>
<pre><code class="php">const CATEGORY_GRAPHQL = &quot;graphql&quot;;
const CATEGORY_INTERNAL = &quot;internal&quot;;
</code></pre>

<p><strong>Class Methods:</strong> </p>
<pre><code class="php">/**
 * An array of locations within the source GraphQL document which correspond to this error.
 *
 * Each entry has information about `line` and `column` within source GraphQL document:
 * $location-&gt;line;
 * $location-&gt;column;
 *
 * Errors during validation often contain multiple locations, for example to
 * point out to field mentioned in multiple fragments. Errors during execution include a
 * single location, the field which produced the error.
 *
 * @return SourceLocation[]
 *
 * @api
 */
function getLocations()
</code></pre>

<pre><code class="php">/**
 * Returns an array describing the path from the root value to the field which produced this error.
 * Only included for execution errors.
 *
 * @return mixed[]|null
 *
 * @api
 */
function getPath()
</code></pre>

<h1 id="graphqlerrorwarning">GraphQL\Error\Warning</h1>
<p>Encapsulates warnings produced by the library.</p>
<p>Warnings can be suppressed (individually or all) if required.
Also it is possible to override warning handler (which is <strong>trigger_error()</strong> by default)</p>
<p><strong>Class Constants:</strong> </p>
<pre><code class="php">const WARNING_ASSIGN = 2;
const WARNING_CONFIG = 4;
const WARNING_FULL_SCHEMA_SCAN = 8;
const WARNING_CONFIG_DEPRECATION = 16;
const WARNING_NOT_A_TYPE = 32;
const ALL = 63;
</code></pre>

<p><strong>Class Methods:</strong> </p>
<pre><code class="php">/**
 * Sets warning handler which can intercept all system warnings.
 * When not set, trigger_error() is used to notify about warnings.
 *
 * @api
 */
static function setWarningHandler(callable $warningHandler = null)
</code></pre>

<pre><code class="php">/**
 * Suppress warning by id (has no effect when custom warning handler is set)
 *
 * Usage example:
 * Warning::suppress(Warning::WARNING_NOT_A_TYPE)
 *
 * When passing true - suppresses all warnings.
 *
 * @param bool|int $suppress
 *
 * @api
 */
static function suppress($suppress = true)
</code></pre>

<pre><code class="php">/**
 * Re-enable previously suppressed warning by id
 *
 * Usage example:
 * Warning::suppress(Warning::WARNING_NOT_A_TYPE)
 *
 * When passing true - re-enables all warnings.
 *
 * @param bool|int $enable
 *
 * @api
 */
static function enable($enable = true)
</code></pre>

<h1 id="graphqlerrorclientaware">GraphQL\Error\ClientAware</h1>
<p>This interface is used for <a href="../error-handling/">default error formatting</a>.</p>
<p>Only errors implementing this interface (and returning true from <code>isClientSafe()</code>)
will be formatted with original error message.</p>
<p>All other errors will be formatted with generic "Internal server error".</p>
<p><strong>Interface Methods:</strong> </p>
<pre><code class="php">/**
 * Returns true when exception message is safe to be displayed to a client.
 *
 * @return bool
 *
 * @api
 */
function isClientSafe()
</code></pre>

<pre><code class="php">/**
 * Returns string describing a category of the error.
 *
 * Value &quot;graphql&quot; is reserved for errors produced by query parsing or validation, do not use it.
 *
 * @return string
 *
 * @api
 */
function getCategory()
</code></pre>

<h1 id="graphqlerrordebug">GraphQL\Error\Debug</h1>
<p>Collection of flags for <a href="../error-handling/#debugging-tools">error debugging</a>.</p>
<p><strong>Class Constants:</strong> </p>
<pre><code class="php">const INCLUDE_DEBUG_MESSAGE = 1;
const INCLUDE_TRACE = 2;
const RETHROW_INTERNAL_EXCEPTIONS = 4;
const RETHROW_UNSAFE_EXCEPTIONS = 8;
</code></pre>

<h1 id="graphqlerrorformattederror">GraphQL\Error\FormattedError</h1>
<p>This class is used for <a href="../error-handling/">default error formatting</a>.
It converts PHP exceptions to <a href="https://facebook.github.io/graphql/#sec-Errors">spec-compliant errors</a>
and provides tools for error debugging.</p>
<p><strong>Class Methods:</strong> </p>
<pre><code class="php">/**
 * Set default error message for internal errors formatted using createFormattedError().
 * This value can be overridden by passing 3rd argument to `createFormattedError()`.
 *
 * @param string $msg
 *
 * @api
 */
static function setInternalErrorMessage($msg)
</code></pre>

<pre><code class="php">/**
 * Standard GraphQL error formatter. Converts any exception to array
 * conforming to GraphQL spec.
 *
 * This method only exposes exception message when exception implements ClientAware interface
 * (or when debug flags are passed).
 *
 * For a list of available debug flags see GraphQL\Error\Debug constants.
 *
 * @param Throwable $e
 * @param bool|int  $debug
 * @param string    $internalErrorMessage
 *
 * @return mixed[]
 *
 * @throws Throwable
 *
 * @api
 */
static function createFromException($e, $debug = false, $internalErrorMessage = null)
</code></pre>

<pre><code class="php">/**
 * Returns error trace as serializable array
 *
 * @param Throwable $error
 *
 * @return mixed[]
 *
 * @api
 */
static function toSafeTrace($error)
</code></pre>

<h1 id="graphqlserverstandardserver">GraphQL\Server\StandardServer</h1>
<p>GraphQL server compatible with both: <a href="https://github.com/graphql/express-graphql">express-graphql</a>
and <a href="https://github.com/apollographql/graphql-server">Apollo Server</a>.
Usage Example:</p>
<pre><code>$server = new StandardServer([
  'schema' =&gt; $mySchema
]);
$server-&gt;handleRequest();
</code></pre>
<p>Or using <a href="./#graphqlserverserverconfig">ServerConfig</a> instance:</p>
<pre><code>$config = GraphQL\Server\ServerConfig::create()
    -&gt;setSchema($mySchema)
    -&gt;setContext($myContext);

$server = new GraphQL\Server\StandardServer($config);
$server-&gt;handleRequest();
</code></pre>
<p>See <a href="../executing-queries/#using-server">dedicated section in docs</a> for details.</p>
<p><strong>Class Methods:</strong> </p>
<pre><code class="php">/**
 * Converts and exception to error and sends spec-compliant HTTP 500 error.
 * Useful when an exception is thrown somewhere outside of server execution context
 * (e.g. during schema instantiation).
 *
 * @param Throwable $error
 * @param bool      $debug
 * @param bool      $exitWhenDone
 *
 * @api
 */
static function send500Error($error, $debug = false, $exitWhenDone = false)
</code></pre>

<pre><code class="php">/**
 * Creates new instance of a standard GraphQL HTTP server
 *
 * @param ServerConfig|mixed[] $config
 *
 * @api
 */
function __construct($config)
</code></pre>

<pre><code class="php">/**
 * Parses HTTP request, executes and emits response (using standard PHP `header` function and `echo`)
 *
 * By default (when $parsedBody is not set) it uses PHP globals to parse a request.
 * It is possible to implement request parsing elsewhere (e.g. using framework Request instance)
 * and then pass it to the server.
 *
 * See `executeRequest()` if you prefer to emit response yourself
 * (e.g. using Response object of some framework)
 *
 * @param OperationParams|OperationParams[] $parsedBody
 * @param bool                              $exitWhenDone
 *
 * @api
 */
function handleRequest($parsedBody = null, $exitWhenDone = false)
</code></pre>

<pre><code class="php">/**
 * Executes GraphQL operation and returns execution result
 * (or promise when promise adapter is different from SyncPromiseAdapter).
 *
 * By default (when $parsedBody is not set) it uses PHP globals to parse a request.
 * It is possible to implement request parsing elsewhere (e.g. using framework Request instance)
 * and then pass it to the server.
 *
 * PSR-7 compatible method executePsrRequest() does exactly this.
 *
 * @param OperationParams|OperationParams[] $parsedBody
 *
 * @return ExecutionResult|ExecutionResult[]|Promise
 *
 * @throws InvariantViolation
 *
 * @api
 */
function executeRequest($parsedBody = null)
</code></pre>

<pre><code class="php">/**
 * Executes PSR-7 request and fulfills PSR-7 response.
 *
 * See `executePsrRequest()` if you prefer to create response yourself
 * (e.g. using specific JsonResponse instance of some framework).
 *
 * @return ResponseInterface|Promise
 *
 * @api
 */
function processPsrRequest(
    Psr\Http\Message\ServerRequestInterface $request,
    Psr\Http\Message\ResponseInterface $response,
    Psr\Http\Message\StreamInterface $writableBodyStream
)
</code></pre>

<pre><code class="php">/**
 * Executes GraphQL operation and returns execution result
 * (or promise when promise adapter is different from SyncPromiseAdapter)
 *
 * @return ExecutionResult|ExecutionResult[]|Promise
 *
 * @api
 */
function executePsrRequest(Psr\Http\Message\ServerRequestInterface $request)
</code></pre>

<pre><code class="php">/**
 * Returns an instance of Server helper, which contains most of the actual logic for
 * parsing / validating / executing request (which could be re-used by other server implementations)
 *
 * @return Helper
 *
 * @api
 */
function getHelper()
</code></pre>

<h1 id="graphqlserverserverconfig">GraphQL\Server\ServerConfig</h1>
<p>Server configuration class.
Could be passed directly to server constructor. List of options accepted by <strong>create</strong> method is
<a href="../executing-queries/#server-configuration-options">described in docs</a>.</p>
<p>Usage example:</p>
<pre><code>$config = GraphQL\Server\ServerConfig::create()
    -&gt;setSchema($mySchema)
    -&gt;setContext($myContext);

$server = new GraphQL\Server\StandardServer($config);
</code></pre>
<p><strong>Class Methods:</strong> </p>
<pre><code class="php">/**
 * Converts an array of options to instance of ServerConfig
 * (or just returns empty config when array is not passed).
 *
 * @param mixed[] $config
 *
 * @return ServerConfig
 *
 * @api
 */
static function create(array $config = [])
</code></pre>

<pre><code class="php">/**
 * @return self
 *
 * @api
 */
function setSchema(GraphQL\Type\Schema $schema)
</code></pre>

<pre><code class="php">/**
 * @param mixed|callable $context
 *
 * @return self
 *
 * @api
 */
function setContext($context)
</code></pre>

<pre><code class="php">/**
 * @param mixed|callable $rootValue
 *
 * @return self
 *
 * @api
 */
function setRootValue($rootValue)
</code></pre>

<pre><code class="php">/**
 * Expects function(Throwable $e) : array
 *
 * @return self
 *
 * @api
 */
function setErrorFormatter(callable $errorFormatter)
</code></pre>

<pre><code class="php">/**
 * Expects function(array $errors, callable $formatter) : array
 *
 * @return self
 *
 * @api
 */
function setErrorsHandler(callable $handler)
</code></pre>

<pre><code class="php">/**
 * Set validation rules for this server.
 *
 * @param ValidationRule[]|callable $validationRules
 *
 * @return self
 *
 * @api
 */
function setValidationRules($validationRules)
</code></pre>

<pre><code class="php">/**
 * @return self
 *
 * @api
 */
function setFieldResolver(callable $fieldResolver)
</code></pre>

<pre><code class="php">/**
 * Expects function($queryId, OperationParams $params) : string|DocumentNode
 *
 * This function must return query string or valid DocumentNode.
 *
 * @return self
 *
 * @api
 */
function setPersistentQueryLoader(callable $persistentQueryLoader)
</code></pre>

<pre><code class="php">/**
 * Set response debug flags. See GraphQL\Error\Debug class for a list of all available flags
 *
 * @param bool|int $set
 *
 * @return self
 *
 * @api
 */
function setDebug($set = true)
</code></pre>

<pre><code class="php">/**
 * Allow batching queries (disabled by default)
 *
 * @param bool $enableBatching
 *
 * @return self
 *
 * @api
 */
function setQueryBatching($enableBatching)
</code></pre>

<pre><code class="php">/**
 * @return self
 *
 * @api
 */
function setPromiseAdapter(GraphQL\Executor\Promise\PromiseAdapter $promiseAdapter)
</code></pre>

<h1 id="graphqlserverhelper">GraphQL\Server\Helper</h1>
<p>Contains functionality that could be re-used by various server implementations</p>
<p><strong>Class Methods:</strong> </p>
<pre><code class="php">/**
 * Parses HTTP request using PHP globals and returns GraphQL OperationParams
 * contained in this request. For batched requests it returns an array of OperationParams.
 *
 * This function does not check validity of these params
 * (validation is performed separately in validateOperationParams() method).
 *
 * If $readRawBodyFn argument is not provided - will attempt to read raw request body
 * from `php://input` stream.
 *
 * Internally it normalizes input to $method, $bodyParams and $queryParams and
 * calls `parseRequestParams()` to produce actual return value.
 *
 * For PSR-7 request parsing use `parsePsrRequest()` instead.
 *
 * @return OperationParams|OperationParams[]
 *
 * @throws RequestError
 *
 * @api
 */
function parseHttpRequest(callable $readRawBodyFn = null)
</code></pre>

<pre><code class="php">/**
 * Parses normalized request params and returns instance of OperationParams
 * or array of OperationParams in case of batch operation.
 *
 * Returned value is a suitable input for `executeOperation` or `executeBatch` (if array)
 *
 * @param string  $method
 * @param mixed[] $bodyParams
 * @param mixed[] $queryParams
 *
 * @return OperationParams|OperationParams[]
 *
 * @throws RequestError
 *
 * @api
 */
function parseRequestParams($method, array $bodyParams, array $queryParams)
</code></pre>

<pre><code class="php">/**
 * Checks validity of OperationParams extracted from HTTP request and returns an array of errors
 * if params are invalid (or empty array when params are valid)
 *
 * @return Error[]
 *
 * @api
 */
function validateOperationParams(GraphQL\Server\OperationParams $params)
</code></pre>

<pre><code class="php">/**
 * Executes GraphQL operation with given server configuration and returns execution result
 * (or promise when promise adapter is different from SyncPromiseAdapter)
 *
 * @return ExecutionResult|Promise
 *
 * @api
 */
function executeOperation(GraphQL\Server\ServerConfig $config, GraphQL\Server\OperationParams $op)
</code></pre>

<pre><code class="php">/**
 * Executes batched GraphQL operations with shared promise queue
 * (thus, effectively batching deferreds|promises of all queries at once)
 *
 * @param OperationParams[] $operations
 *
 * @return ExecutionResult|ExecutionResult[]|Promise
 *
 * @api
 */
function executeBatch(GraphQL\Server\ServerConfig $config, array $operations)
</code></pre>

<pre><code class="php">/**
 * Send response using standard PHP `header()` and `echo`.
 *
 * @param Promise|ExecutionResult|ExecutionResult[] $result
 * @param bool                                      $exitWhenDone
 *
 * @api
 */
function sendResponse($result, $exitWhenDone = false)
</code></pre>

<pre><code class="php">/**
 * Converts PSR-7 request to OperationParams[]
 *
 * @return OperationParams[]|OperationParams
 *
 * @throws RequestError
 *
 * @api
 */
function parsePsrRequest(Psr\Http\Message\ServerRequestInterface $request)
</code></pre>

<pre><code class="php">/**
 * Converts query execution result to PSR-7 response
 *
 * @param Promise|ExecutionResult|ExecutionResult[] $result
 *
 * @return Promise|ResponseInterface
 *
 * @api
 */
function toPsrResponse(
    $result,
    Psr\Http\Message\ResponseInterface $response,
    Psr\Http\Message\StreamInterface $writableBodyStream
)
</code></pre>

<h1 id="graphqlserveroperationparams">GraphQL\Server\OperationParams</h1>
<p>Structure representing parsed HTTP parameters for GraphQL operation</p>
<p><strong>Class Props:</strong> </p>
<pre><code class="php">/**
 * Id of the query (when using persistent queries).
 *
 * Valid aliases (case-insensitive):
 * - id
 * - queryId
 * - documentId
 *
 * @api
 * @var string
 */
public $queryId;

/**
 * @api
 * @var string
 */
public $query;

/**
 * @api
 * @var string
 */
public $operation;

/**
 * @api
 * @var mixed[]|null
 */
public $variables;
</code></pre>

<p><strong>Class Methods:</strong> </p>
<pre><code class="php">/**
 * Creates an instance from given array
 *
 * @param mixed[] $params
 * @param bool    $readonly
 *
 * @return OperationParams
 *
 * @api
 */
static function create(array $params, $readonly = false)
</code></pre>

<pre><code class="php">/**
 * @param string $key
 *
 * @return mixed
 *
 * @api
 */
function getOriginalInput($key)
</code></pre>

<pre><code class="php">/**
 * Indicates that operation is executed in read-only context
 * (e.g. via HTTP GET request)
 *
 * @return bool
 *
 * @api
 */
function isReadOnly()
</code></pre>

<h1 id="graphqlutilsbuildschema">GraphQL\Utils\BuildSchema</h1>
<p>Build instance of <code>GraphQL\Type\Schema</code> out of type language definition (string or parsed AST)
See <a href="../type-system/type-language/">section in docs</a> for details.</p>
<p><strong>Class Methods:</strong> </p>
<pre><code class="php">/**
 * A helper function to build a GraphQLSchema directly from a source
 * document.
 *
 * @param DocumentNode|Source|string $source
 * @param bool[]                     $options
 *
 * @return Schema
 *
 * @api
 */
static function build($source, callable $typeConfigDecorator = null, array $options = [])
</code></pre>

<pre><code class="php">/**
 * This takes the ast of a schema document produced by the parse function in
 * GraphQL\Language\Parser.
 *
 * If no schema definition is provided, then it will look for types named Query
 * and Mutation.
 *
 * Given that AST it constructs a GraphQL\Type\Schema. The resulting schema
 * has no resolve methods, so execution will use default resolvers.
 *
 * Accepts options as a third argument:
 *
 *    - commentDescriptions:
 *        Provide true to use preceding comments as the description.
 *
 * @param bool[] $options
 *
 * @return Schema
 *
 * @throws Error
 *
 * @api
 */
static function buildAST(
    GraphQL\Language\AST\DocumentNode $ast,
    callable $typeConfigDecorator = null,
    array $options = []
)
</code></pre>

<h1 id="graphqlutilsast">GraphQL\Utils\AST</h1>
<p>Various utilities dealing with AST</p>
<p><strong>Class Methods:</strong> </p>
<pre><code class="php">/**
 * Convert representation of AST as an associative array to instance of GraphQL\Language\AST\Node.
 *
 * For example:
 *
 * ```php
 * AST::fromArray([
 *     'kind' =&gt; 'ListValue',
 *     'values' =&gt; [
 *         ['kind' =&gt; 'StringValue', 'value' =&gt; 'my str'],
 *         ['kind' =&gt; 'StringValue', 'value' =&gt; 'my other str']
 *     ],
 *     'loc' =&gt; ['start' =&gt; 21, 'end' =&gt; 25]
 * ]);
 * ```
 *
 * Will produce instance of `ListValueNode` where `values` prop is a lazily-evaluated `NodeList`
 * returning instances of `StringValueNode` on access.
 *
 * This is a reverse operation for AST::toArray($node)
 *
 * @param mixed[] $node
 *
 * @api
 */
static function fromArray(array $node)
</code></pre>

<pre><code class="php">/**
 * Convert AST node to serializable array
 *
 * @return mixed[]
 *
 * @api
 */
static function toArray(GraphQL\Language\AST\Node $node)
</code></pre>

<pre><code class="php">/**
 * Produces a GraphQL Value AST given a PHP value.
 *
 * Optionally, a GraphQL type may be provided, which will be used to
 * disambiguate between value primitives.
 *
 * | PHP Value     | GraphQL Value        |
 * | ------------- | -------------------- |
 * | Object        | Input Object         |
 * | Assoc Array   | Input Object         |
 * | Array         | List                 |
 * | Boolean       | Boolean              |
 * | String        | String / Enum Value  |
 * | Int           | Int                  |
 * | Float         | Int / Float          |
 * | Mixed         | Enum Value           |
 * | null          | NullValue            |
 *
 * @param Type|mixed|null $value
 *
 * @return ObjectValueNode|ListValueNode|BooleanValueNode|IntValueNode|FloatValueNode|EnumValueNode|StringValueNode|NullValueNode
 *
 * @api
 */
static function astFromValue($value, GraphQL\Type\Definition\InputType $type)
</code></pre>

<pre><code class="php">/**
 * Produces a PHP value given a GraphQL Value AST.
 *
 * A GraphQL type must be provided, which will be used to interpret different
 * GraphQL Value literals.
 *
 * Returns `null` when the value could not be validly coerced according to
 * the provided type.
 *
 * | GraphQL Value        | PHP Value     |
 * | -------------------- | ------------- |
 * | Input Object         | Assoc Array   |
 * | List                 | Array         |
 * | Boolean              | Boolean       |
 * | String               | String        |
 * | Int / Float          | Int / Float   |
 * | Enum Value           | Mixed         |
 * | Null Value           | null          |
 *
 * @param ValueNode|null $valueNode
 * @param mixed[]|null   $variables
 *
 * @return mixed[]|stdClass|null
 *
 * @throws Exception
 *
 * @api
 */
static function valueFromAST($valueNode, GraphQL\Type\Definition\InputType $type, array $variables = null)
</code></pre>

<pre><code class="php">/**
 * Produces a PHP value given a GraphQL Value AST.
 *
 * Unlike `valueFromAST()`, no type is provided. The resulting PHP value
 * will reflect the provided GraphQL value AST.
 *
 * | GraphQL Value        | PHP Value     |
 * | -------------------- | ------------- |
 * | Input Object         | Assoc Array   |
 * | List                 | Array         |
 * | Boolean              | Boolean       |
 * | String               | String        |
 * | Int / Float          | Int / Float   |
 * | Enum                 | Mixed         |
 * | Null                 | null          |
 *
 * @param Node         $valueNode
 * @param mixed[]|null $variables
 *
 * @return mixed
 *
 * @throws Exception
 *
 * @api
 */
static function valueFromASTUntyped($valueNode, array $variables = null)
</code></pre>

<pre><code class="php">/**
 * Returns type definition for given AST Type node
 *
 * @param NamedTypeNode|ListTypeNode|NonNullTypeNode $inputTypeNode
 *
 * @return Type|null
 *
 * @throws Exception
 *
 * @api
 */
static function typeFromAST(GraphQL\Type\Schema $schema, $inputTypeNode)
</code></pre>

<pre><code class="php">/**
 * Returns operation type (&quot;query&quot;, &quot;mutation&quot; or &quot;subscription&quot;) given a document and operation name
 *
 * @param string $operationName
 *
 * @return bool
 *
 * @api
 */
static function getOperation(GraphQL\Language\AST\DocumentNode $document, $operationName = null)
</code></pre>

<h1 id="graphqlutilsschemaprinter">GraphQL\Utils\SchemaPrinter</h1>
<p>Given an instance of Schema, prints it in GraphQL type language.</p>
<p><strong>Class Methods:</strong> </p>
<pre><code class="php">/**
 * Accepts options as a second argument:
 *
 *    - commentDescriptions:
 *        Provide true to use preceding comments as the description.
 *
 * @param bool[] $options
 *
 * @api
 */
static function doPrint(GraphQL\Type\Schema $schema, array $options = [])
</code></pre>

<pre><code class="php">/**
 * @param bool[] $options
 *
 * @api
 */
static function printIntrospectionSchema(GraphQL\Type\Schema $schema, array $options = [])
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="../how-it-works/" class="btn btn-neutral" title="How it works"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../how-it-works/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
